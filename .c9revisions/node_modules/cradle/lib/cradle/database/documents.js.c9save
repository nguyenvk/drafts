{"ts":1367790276774,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var querystring = require('querystring'),\n    Args = require('vargs').Constructor,\n    cradle = require('../../cradle'),\n    Database = require('./index').Database;\n\n//\n// Perform a HEAD request\n//\nDatabase.prototype.head = function (id, callback) {\n    this.query({\n        method: 'HEAD', \n        path: cradle.escape(id)\n    }, callback);\n};\n\n// Fetch either a single document from the database, or cache,\n// or multiple documents from the database.\n// If it's a single doc from the db, attempt to save it to the cache.\nDatabase.prototype.get = function (id, rev) {\n    var args = new (Args)(arguments),\n        options = null,\n        that = this;\n\n    if (Array.isArray(id)) { // Bulk GET\n        this.query({\n            method: 'POST', \n            path: '/_all_docs', \n            query: { include_docs: true }, \n            body: { keys: id },\n        }, function (err, res) { \n            args.callback(err, res) \n        });\n    } else {\n        if (rev && args.length === 2) {\n            if      (typeof(rev) === 'string') { options = { rev: rev } }\n            else if (typeof(rev) === 'object') { options = rev }\n        } else if (this.cache.has(id)) {\n            return args.callback(null, this.cache.get(id));\n        }\n        this.query({\n            path: cradle.escape(id),\n            query: options\n        }, function (err, res) {\n            if (! err) that.cache.save(res.id, res.json);\n            args.callback(err, res);\n        });\n    }\n};\n\n//\n// PUT a document, and write through cache\n//\nDatabase.prototype.put = function (id, doc, callback) {\n    var cache = this.cache;\n    if (typeof(id) !== 'string') { throw new(TypeError)(\"id must be a string\") }\n    this.query({\n        method: 'PUT', \n        path: cradle.escape(id), \n        body: doc\n    }, function (e, res) {\n        if (! e) { cache.save(id, cradle.merge({}, doc, { _id: id, _rev: res.rev })) }\n        callback && callback(e, res);\n    });\n};\n\n//\n// POST a document, and write through cache\n//\nDatabase.prototype.post = function (doc, callback) {\n    var cache = this.cache;\n    this.query({\n        method: 'POST', \n        path: '/', \n        body: doc\n    }, function (e, res) {\n        if (! e) { cache.save(res.id, cradle.merge({}, doc, { _id: res.id, _rev: res.rev })) }\n        callback && callback(e, res);\n    });\n};\n\nDatabase.prototype.save = function (/* [id], [rev], doc | [doc, ...] */) {\n    var args = new(Args)(arguments),\n        array = args.all.slice(0), doc, id, rev;\n\n    if (Array.isArray(args.first)) {\n        doc = args.first;\n    } else {\n        doc = array.pop(),\n        id  = array.shift(),\n        rev = array.shift();\n    }\n    this._save(id, rev, doc, args.callback);\n};\n\nDatabase.prototype._save = function (id, rev, doc, callback) {\n    var options = this.connection.options;\n    var document = {}, that = this;\n\n    // Bulk Insert\n    if (Array.isArray(doc)) {\n        document.docs = doc;\n        if (options.allOrNothing) { document.all_or_nothing = true }\n        this.query({\n            method: 'POST', \n            path: '/_bulk_docs', \n            body: document\n        }, callback);\n    } else {\n        if (!id && doc._id) {\n            id = doc._id;\n        }\n        \n        // PUT a single document, with an id (Create or Update)\n        if (id) {\n            // Design document\n            if (/^_design\\/(\\w|%|\\-)+$/.test(id) && !('views' in doc)) {\n                document.language = \"javascript\";\n                document.views    =  doc;\n            } else {\n                document = doc;\n            }\n            // Try to set the '_rev' attribute of the document.\n            // If it wasn't passed, attempt to retrieve it from the cache.\n            rev && (document._rev = rev);\n\n            if (document._rev) {\n                this.put(id, document, callback);\n            } else if (this.cache.has(id)) {\n                document._rev = this.cache.get(id)._rev;\n                this.put(id, document, callback);\n            } else {\n                // Attempt to create a new document. If it fails,\n                // because an existing document with that _id exists (409),\n                // perform a HEAD, to get the _rev, and try to re-save.\n                this.put(id, document, function (e, res) {\n                    if (e && e.headers && e.headers.status === 409) { // Conflict\n                        that.head(id, function (e, headers, res) {\n                            if (res === 404 || !headers['etag']) {\n                                return callback({ reason: 'not_found' });\n                            }\n\n                            document._rev = headers['etag'].slice(1, -1);\n                            that.put(id, document, callback);\n                        });\n                    } else { callback(e, res) }\n                });\n            }\n        // POST a single document, without an id (Create)\n        } else {\n            this.post(doc, callback);\n        }\n    }\n};\n\nDatabase.prototype.merge = function (/* [id], doc */) {\n    var args     = Array.prototype.slice.call(arguments),\n        callback = args.pop(),\n        doc      = args.pop(),\n        id       = args.pop() || doc._id;\n\n    this._merge(id, doc, callback);\n};\n\nDatabase.prototype._merge = function (id, doc, callback) {\n    var that = this;\n    this.get(id, function (e, res) {\n        if (e) { return callback(e) }\n        doc = cradle.merge({}, res.json || res, doc);\n        that.save(id, res._rev, doc, callback);\n    });\n};\n\nDatabase.prototype.insert = function () {\n    throw new Error(\"`insert` is deprecated, use `save` instead\");\n};\n\nDatabase.prototype.update = function (path, id, options) {\n    var args = new(Args)(arguments);\n    path = path.split('/');\n\n    if (id) {\n      return this.query({\n        method: 'PUT', \n        path: ['_design', path[0], '_update', path[1], id].map(querystring.escape).join('/'), \n        query: options\n      }, args.callback);\n    } \n    \n    return this.query({\n        method: 'POST', \n        path: ['_design', path[0], '_update', path[1]].map(querystring.escape).join('/'), \n        query: options, \n    }, args.callback);\n};\n\n// Delete a document\n// if the _rev wasn't supplied, we attempt to retrieve it from the\n// cache. If the deletion was successful, we purge the cache.\nDatabase.prototype.remove = function (id, rev) {\n    var that = this, doc, args = new(Args)(arguments);\n\n    if (typeof(rev) !== 'string') {\n        if (doc = this.cache.get(id)) { rev = doc._rev }\n        else                          { throw new(Error)(\"rev needs to be supplied\") }\n    }\n    \n    this.query({\n        method: 'DELETE', \n        path: cradle.escape(id), \n        query: { rev: rev }\n    }, function (err, res) {\n        if (! err) { that.cache.purge(id) }\n        args.callback(err, res);\n    });\n};"]],"start1":0,"start2":0,"length1":0,"length2":6818}]],"length":6818}
