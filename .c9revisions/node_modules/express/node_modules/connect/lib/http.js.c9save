{"ts":1365968461971,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/*!\n * Connect - HTTPServer\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar http = require('http')\n  , parse = require('url').parse\n  , assert = require('assert');\n\n// environment\n\nvar env = process.env.NODE_ENV || 'development';\n\n/**\n * Initialize a new `Server` with the given `middleware`.\n *\n * Examples:\n *\n *     var server = connect.createServer(\n *         connect.favicon()\n *       , connect.logger()\n *       , connect.static(__dirname + '/public')\n *     );\n *\n * @params {Array} middleware \n * @return {Server}\n * @api public\n */\n\nvar Server = exports.Server = function HTTPServer(middleware) {\n  this.stack = [];\n  middleware.forEach(function(fn){\n    this.use(fn);\n  }, this);\n  http.Server.call(this, this.handle);\n};\n\n/**\n * Inherit from `http.Server.prototype`.\n */\n\nServer.prototype.__proto__ = http.Server.prototype;\n\n/**\n * Utilize the given middleware `handle` to the given `route`,\n * defaulting to _/_. This \"route\" is the mount-point for the\n * middleware, when given a value other than _/_ the middleware\n * is only effective when that segment is present in the request's\n * pathname.\n *\n * For example if we were to mount a function at _/admin_, it would\n * be invoked on _/admin_, and _/admin/settings_, however it would\n * not be invoked for _/_, or _/posts_.\n *\n * This is effectively the same as passing middleware to `connect.createServer()`,\n * however provides a progressive api.\n *\n * Examples:\n *\n *      var server = connect.createServer();\n *      server.use(connect.favicon());\n *      server.use(connect.logger());\n *      server.use(connect.static(__dirname + '/public'));\n *\n * If we wanted to prefix static files with _/public_, we could\n * \"mount\" the `static()` middleware:\n *\n *      server.use('/public', connect.static(__dirname + '/public'));\n *\n * This api is chainable, meaning the following is valid:\n *\n *      connect.createServer()\n *        .use(connect.favicon())\n *        .use(connect.logger())\n *        .use(connect.static(__dirname + '/public'))\n *        .listen(3000);\n *\n * @param {String|Function} route or handle\n * @param {Function} handle\n * @return {Server}\n * @api public\n */\n\nServer.prototype.use = function(route, handle){\n  this.route = '/';\n\n  // default route to '/'\n  if ('string' != typeof route) {\n    handle = route;\n    route = '/';\n  }\n\n  // wrap sub-apps\n  if ('function' == typeof handle.handle) {\n    var server = handle;\n    server.route = route;\n    handle = function(req, res, next) {\n      server.handle(req, res, next);\n    };\n  }\n\n  // wrap vanilla http.Servers\n  if (handle instanceof http.Server) {\n    handle = handle.listeners('request')[0];\n  }\n\n  // normalize route to not trail with slash\n  if ('/' == route[route.length - 1]) {\n    route = route.substr(0, route.length - 1);\n  }\n\n  // add the middleware\n  this.stack.push({ route: route, handle: handle });\n\n  // allow chaining\n  return this;\n};\n\n/**\n * Handle server requests, punting them down\n * the middleware stack.\n *\n * @api private\n */\n\nServer.prototype.handle = function(req, res, out) {\n  var writeHead = res.writeHead\n    , stack = this.stack\n    , removed = ''\n    , index = 0;\n\n  function next(err) {\n    var layer, path, c;\n    req.url = removed + req.url;\n    req.originalUrl = req.originalUrl || req.url;\n    removed = '';\n\n    layer = stack[index++];\n\n    // all done\n    if (!layer || res.headerSent) {\n      // but wait! we have a parent\n      if (out) return out(err);\n\n      // error\n      if (err) {\n        var msg = 'production' == env\n          ? 'Internal Server Error'\n          : err.stack || err.toString();\n\n        // output to stderr in a non-test env\n        if ('test' != env) console.error(err.stack || err.toString());\n\n        // unable to respond\n        if (res.headerSent) return req.socket.destroy();\n\n        res.statusCode = 500;\n        res.setHeader('Content-Type', 'text/plain');\n        if ('HEAD' == req.method) return res.end();\n        res.end(msg);\n      } else {\n        res.statusCode = 404;\n        res.setHeader('Content-Type', 'text/plain');\n        if ('HEAD' == req.method) return res.end();\n        res.end('Cannot ' + req.method + ' ' + req.url);\n      }\n      return;\n    }\n\n    try {\n      path = parse(req.url).pathname;\n      if (undefined == path) path = '/';\n\n      // skip this layer if the route doesn't match.\n      if (0 != path.indexOf(layer.route)) return next(err);\n\n      c = path[layer.route.length];\n      if (c && '/' != c && '.' != c) return next(err);\n\n      // Call the layer handler\n      // Trim off the part of the url that matches the route\n      removed = layer.route;\n      req.url = req.url.substr(removed.length);\n\n      // Ensure leading slash\n      if ('/' != req.url[0]) req.url = '/' + req.url;\n\n      var arity = layer.handle.length;\n      if (err) {\n        if (arity === 4) {\n          layer.handle(err, req, res, next);\n        } else {\n          next(err);\n        }\n      } else if (arity < 4) {\n        layer.handle(req, res, next);\n      } else {\n        next();\n      }\n    } catch (e) {\n      if (e instanceof assert.AssertionError) {\n        console.error(e.stack + '\\n');\n        next(e);\n      } else {\n        next(e);\n      }\n    }\n  }\n  next();\n};"]],"start1":0,"start2":0,"length1":0,"length2":5284}]],"length":5284}
