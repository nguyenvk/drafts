{"ts":1366086904709,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/*!\n * Express - view\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar path = require('path')\n  , extname = path.extname\n  , dirname = path.dirname\n  , basename = path.basename\n  , utils = require('connect').utils\n  , View = require('./view/view')\n  , partial = require('./view/partial')\n  , union = require('./utils').union\n  , merge = utils.merge\n  , http = require('http')\n  , res = http.ServerResponse.prototype;\n\n/**\n * Expose constructors.\n */\n\nexports = module.exports = View;\n\n/**\n * Export template engine registrar.\n */\n\nexports.register = View.register;\n\n/**\n * Lookup and compile `view` with cache support by supplying\n * both the `cache` object and `cid` string,\n * followed by `options` passed to `exports.lookup()`.\n *\n * @param {String} view\n * @param {Object} cache\n * @param {Object} cid\n * @param {Object} options\n * @return {View}\n * @api private\n */\n\nexports.compile = function(view, cache, cid, options){\n  if (cache && cid && cache[cid]){\n    options.filename = cache[cid].path;\n    return cache[cid];\n  }\n\n  // lookup\n  view = exports.lookup(view, options);\n\n  // hints\n  if (!view.exists) {\n    if (options.hint) hintAtViewPaths(view.original, options);\n    var err = new Error('failed to locate view \"' + view.original.view + '\"');\n    err.view = view.original;\n    throw err;\n  }\n\n  // compile\n  options.filename = view.path;\n  view.fn = view.templateEngine.compile(view.contents, options);\n  cache[cid] = view;\n\n  return view;\n};\n\n/**\n * Lookup `view`, returning an instanceof `View`.\n *\n * Options:\n *\n *   - `root` root directory path\n *   - `defaultEngine` default template engine\n *   - `parentView` parent `View` object\n *   - `cache` cache object\n *   - `cacheid` optional cache id\n *\n * Lookup:\n *\n *   - partial `_<name>`\n *   - any `<name>/index`\n *   - non-layout `../<name>/index`\n *   - any `<root>/<name>`\n *   - partial `<root>/_<name>`\n *\n * @param {String} view\n * @param {Object} options\n * @return {View}\n * @api private\n */\n\nexports.lookup = function(view, options){\n  var orig = view = new View(view, options)\n    , partial = options.isPartial\n    , layout = options.isLayout;\n\n  // Try _ prefix ex: ./views/_<name>.jade\n  // taking precedence over the direct path\n  if (partial) {\n    view = new View(orig.prefixPath, options);\n    if (!view.exists) view = orig;\n  }\n\n  // Try index ex: ./views/user/index.jade\n  if (!layout && !view.exists) view = new View(orig.indexPath, options);\n\n  // Try ../<name>/index ex: ../user/index.jade\n  // when calling partial('user') within the same dir\n  if (!layout && !view.exists) view = new View(orig.upIndexPath, options);\n\n  // Try root ex: <root>/user.jade\n  if (!view.exists) view = new View(orig.rootPath, options);\n\n  // Try root _ prefix ex: <root>/_user.jade\n  if (!view.exists && partial) view = new View(view.prefixPath, options);\n\n  view.original = orig;\n  return view;\n};\n\n/**\n * Partial render helper.\n *\n * @api private\n */\n\nfunction renderPartial(res, view, options, parentLocals, parent){\n  var collection, object, locals;\n\n  if (options) {\n    // collection\n    if (options.collection) {\n      collection = options.collection;\n      delete options.collection;\n    } else if ('length' in options) {\n      collection = options;\n      options = {};\n    }\n\n    // locals\n    if (options.locals) {\n      locals = options.locals;\n      delete options.locals;\n    }\n\n    // object\n    if ('Object' != options.constructor.name) {\n      object = options;\n      options = {};\n    } else if (undefined != options.object) {\n      object = options.object;\n      delete options.object;\n    }\n  } else {\n    options = {};\n  }\n\n  // Inherit locals from parent\n  union(options, parentLocals);\n\n  // Merge locals\n  if (locals) merge(options, locals);\n\n  // Partials dont need layouts\n  options.isPartial = true;\n  options.layout = false;\n\n  // Deduce name from view path\n  var name = options.as || partial.resolveObjectName(view);\n\n  // Render partial\n  function render(){\n    if (object) {\n      if ('string' == typeof name) {\n        options[name] = object;\n      } else if (name === global) {\n        merge(options, object);\n      }\n    }\n    return res.render(view, options, null, parent, true);\n  }\n\n  // Collection support\n  if (collection) {\n    var len = collection.length\n      , buf = ''\n      , keys\n      , key\n      , val;\n\n    options.collectionLength = len;\n\n    if ('number' == typeof len || Array.isArray(collection)) {\n      for (var i = 0; i < len; ++i) {\n        val = collection[i];\n        options.firstInCollection = i == 0;\n        options.indexInCollection = i;\n        options.lastInCollection = i == len - 1;\n        object = val;\n        buf += render();\n      }\n    } else {\n      keys = Object.keys(collection);\n      len = keys.length;\n      options.collectionLength = len;\n      options.collectionKeys = keys;\n      for (var i = 0; i < len; ++i) {\n        key = keys[i];\n        val = collection[key];\n        options.keyInCollection = key;\n        options.firstInCollection = i == 0;\n        options.indexInCollection = i;\n        options.lastInCollection = i == len - 1;\n        object = val;\n        buf += render();\n      }\n    }\n\n    return buf;\n  } else {\n    return render();\n  }\n};\n\n/**\n * Render `view` partial with the given `options`. Optionally a\n * callback `fn(err, str)` may be passed instead of writing to\n * the socket.\n *\n * Options:\n *\n *   - `object` Single object with name derived from the view (unless `as` is present)\n *\n *   - `as` Variable name for each `collection` value, defaults to the view name.\n *     * as: 'something' will add the `something` local variable\n *     * as: this will use the collection value as the template context\n *     * as: global will merge the collection value's properties with `locals`\n *\n *   - `collection` Array of objects, the name is derived from the view name itself.\n *     For example _video.html_ will have a object _video_ available to it.\n *\n * @param  {String} view\n * @param  {Object|Array|Function} options, collection, callback, or object\n * @param  {Function} fn\n * @return {String}\n * @api public\n */\n\nres.partial = function(view, options, fn){\n  var app = this.app\n    , options = options || {}\n    , viewEngine = app.set('view engine')\n    , parent = {};\n\n  // accept callback as second argument\n  if ('function' == typeof options) {\n    fn = options;\n    options = {};\n  }\n\n  // root \"views\" option\n  parent.dirname = app.set('views') || process.cwd() + '/views';\n\n  // utilize \"view engine\" option\n  if (viewEngine) parent.engine = viewEngine;\n\n  // render the partial\n  try {\n    var str = renderPartial(this, view, options, null, parent);\n  } catch (err) {\n    if (fn) {\n      fn(err);\n    } else {\n      this.req.next(err);\n    }\n    return;\n  }\n\n  // callback or transfer\n  if (fn) {\n    fn(null, str);\n  } else {\n    this.send(str);\n  }\n};\n\n/**\n * Render `view` with the given `options` and optional callback `fn`.\n * When a callback function is given a response will _not_ be made\n * automatically, however otherwise a response of _200_ and _text/html_ is given.\n *\n * Options:\n *\n *  - `scope`     Template evaluation context (the value of `this`)\n *  - `debug`     Output debugging information\n *  - `status`    Response status code\n *\n * @param  {String} view\n * @param  {Object|Function} options or callback function\n * @param  {Function} fn\n * @api public\n */\n\nres.render = function(view, opts, fn, parent, sub){\n  // support callback function as second arg\n  if ('function' == typeof opts) {\n    fn = opts, opts = null;\n  }\n\n  try {\n    return this._render(view, opts, fn, parent, sub);\n  } catch (err) {\n    // callback given\n    if (fn) {\n      fn(err);\n    // unwind to root call to prevent multiple callbacks\n    } else if (sub) {\n      throw err;\n    // root template, next(err)\n    } else {\n      this.req.next(err);\n    }\n  }\n};\n\n// private render()\n\nres._render = function(view, opts, fn, parent, sub){\n  var options = {}\n    , self = this\n    , app = this.app\n    , helpers = app._locals\n    , dynamicHelpers = app.dynamicViewHelpers\n    , viewOptions = app.set('view options')\n    , root = app.set('views') || process.cwd() + '/views';\n\n  // cache id\n  var cid = app.enabled('view cache')\n    ? view + (parent ? ':' + parent.path : '')\n    : false;\n\n  // merge \"view options\"\n  if (viewOptions) merge(options, viewOptions);\n\n  // merge res._locals\n  if (this._locals) merge(options, this._locals);\n\n  // merge render() options\n  if (opts) merge(options, opts);\n\n  // merge render() .locals\n  if (opts && opts.locals) merge(options, opts.locals);\n\n  // status support\n  if (options.status) this.statusCode = options.status;\n\n  // capture attempts\n  options.attempts = [];\n\n  var partial = options.isPartial\n    , layout = options.layout;\n\n  // Layout support\n  if (true === layout || undefined === layout) {\n    layout = 'layout';\n  }\n\n  // Default execution scope to a plain object\n  options.scope = options.scope || {};\n\n  // Populate view\n  options.parentView = parent;\n\n  // \"views\" setting\n  options.root = root;\n\n  // \"view engine\" setting\n  options.defaultEngine = app.set('view engine');\n\n  // charset option\n  if (options.charset) this.charset = options.charset;\n\n  // Dynamic helper support\n  if (false !== options.dynamicHelpers) {\n    // cache\n    if (!this.__dynamicHelpers) {\n      this.__dynamicHelpers = {};\n      for (var key in dynamicHelpers) {\n        this.__dynamicHelpers[key] = dynamicHelpers[key].call(\n            this.app\n          , this.req\n          , this);\n      }\n    }\n\n    // apply\n    merge(options, this.__dynamicHelpers);\n  }\n\n  // Merge view helpers\n  union(options, helpers);\n\n  // Always expose partial() as a local\n  options.partial = function(path, opts){\n    return renderPartial(self, path, opts, options, view);\n  };\n\n  // View lookup\n  options.hint = app.enabled('hints');\n  view = exports.compile(view, app.cache, cid, options);\n\n  // layout helper\n  options.layout = function(path){\n    layout = path;\n  };\n\n  // render\n  var str = view.fn.call(options.scope, options);\n\n  // layout expected\n  if (layout) {\n    options.isLayout = true;\n    options.layout = false;\n    options.body = str;\n    this.render(layout, options, fn, view, true);\n  // partial return\n  } else if (partial) {\n    return str;\n  // render complete, and\n  // callback given\n  } else if (fn) {\n    fn(null, str);\n  // respond\n  } else {\n    this.send(str);\n  }\n}\n\n/**\n * Hint at view path resolution, outputting the\n * paths that Express has tried.\n *\n * @api private\n */\n\nfunction hintAtViewPaths(view, options) {\n  console.error();\n  console.error('failed to locate view \"' + view.view + '\", tried:');\n  options.attempts.forEach(function(path){\n    console.error('  - %s', path);\n  });\n  console.error();\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":10811}]],"length":10811}
