{"ts":1365968453453,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/*!\n * Express - Router\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Route = require('./route')\n  , Collection = require('./collection')\n  , utils = require('../utils')\n  , parse = require('url').parse\n  , toArray = utils.toArray;\n\n/**\n * Expose `Router` constructor.\n */\n\nexports = module.exports = Router;\n\n/**\n * Expose HTTP methods.\n */\n\nvar methods = exports.methods = require('./methods');\n\n/**\n * Initialize a new `Router` with the given `app`.\n * \n * @param {express.HTTPServer} app\n * @api private\n */\n\nfunction Router(app) {\n  var self = this;\n  this.app = app;\n  this.routes = {};\n  this.params = {};\n  this._params = [];\n\n  this.middleware = function(req, res, next){\n    self._dispatch(req, res, next);\n  };\n}\n\n/**\n * Register a param callback `fn` for the given `name`.\n *\n * @param {String|Function} name\n * @param {Function} fn\n * @return {Router} for chaining\n * @api public\n */\n\nRouter.prototype.param = function(name, fn){\n  // param logic\n  if ('function' == typeof name) {\n    this._params.push(name);\n    return;\n  }\n\n  // apply param functions\n  var params = this._params\n    , len = params.length\n    , ret;\n\n  for (var i = 0; i < len; ++i) {\n    if (ret = params[i](name, fn)) {\n      fn = ret;\n    }\n  }\n\n  // ensure we end up with a\n  // middleware function\n  if ('function' != typeof fn) {\n    throw new Error('invalid param() call for ' + name + ', got ' + fn);\n  }\n\n  (this.params[name] = this.params[name] || []).push(fn);\n  return this;\n};\n\n/**\n * Return a `Collection` of all routes defined.\n *\n * @return {Collection}\n * @api public\n */\n\nRouter.prototype.all = function(){\n  return this.find(function(){\n    return true;\n  });\n};\n\n/**\n * Remove the given `route`, returns\n * a bool indicating if the route was present\n * or not.\n *\n * @param {Route} route\n * @return {Boolean}\n * @api public\n */\n\nRouter.prototype.remove = function(route){\n  var routes = this.routes[route.method]\n    , len = routes.length;\n\n  for (var i = 0; i < len; ++i) {\n    if (route == routes[i]) {\n      routes.splice(i, 1);\n      return true;\n    }\n  }\n};\n\n/**\n * Return routes with route paths matching `path`.\n *\n * @param {String} method\n * @param {String} path\n * @return {Collection}\n * @api public\n */\n\nRouter.prototype.lookup = function(method, path){\n  return this.find(function(route){\n    return path == route.path\n      && (route.method == method\n      || method == 'all');\n  });\n};\n\n/**\n * Return routes with regexps that match the given `url`.\n *\n * @param {String} method\n * @param {String} url\n * @return {Collection}\n * @api public\n */\n\nRouter.prototype.match = function(method, url){\n  return this.find(function(route){\n    return route.match(url)\n      && (route.method == method\n      || method == 'all');\n  });\n};\n\n/**\n * Find routes based on the return value of `fn`\n * which is invoked once per route.\n *\n * @param {Function} fn\n * @return {Collection}\n * @api public\n */\n\nRouter.prototype.find = function(fn){\n  var len = methods.length\n    , ret = new Collection(this)\n    , method\n    , routes\n    , route;\n\n  for (var i = 0; i < len; ++i) {\n    method = methods[i];\n    routes = this.routes[method];\n    if (!routes) continue;\n    for (var j = 0, jlen = routes.length; j < jlen; ++j) {\n      route = routes[j];\n      if (fn(route)) ret.push(route);\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Route dispatcher aka the route \"middleware\".\n *\n * @param {IncomingMessage} req\n * @param {ServerResponse} res\n * @param {Function} next\n * @api private\n */\n\nRouter.prototype._dispatch = function(req, res, next){\n  var params = this.params\n    , self = this;\n\n  // route dispatch\n  (function pass(i, err){\n    var paramCallbacks\n      , paramIndex = 0\n      , paramVal\n      , route\n      , keys\n      , key\n      , ret;\n\n    // match next route\n    function nextRoute(err) {\n      pass(req._route_index + 1, err);\n    }\n\n    // match route\n    req.route = route = self._match(req, i);\n\n    // implied OPTIONS\n    if (!route && 'OPTIONS' == req.method) return self._options(req, res);\n\n    // no route\n    if (!route) return next(err);\n\n    // we have a route\n    // start at param 0\n    req.params = route.params;\n    keys = route.keys;\n    i = 0;\n\n    // param callbacks\n    function param(err) {\n      paramIndex = 0;\n      key = keys[i++];\n      paramVal = key && req.params[key.name];\n      paramCallbacks = key && params[key.name];\n\n      try {\n        if ('route' == err) {\n          nextRoute();\n        } else if (err) {\n          i = 0;\n          callbacks(err);\n        } else if (paramCallbacks && undefined !== paramVal) {\n          paramCallback();\n        } else if (key) {\n          param();\n        } else {\n          i = 0;\n          callbacks();\n        }\n      } catch (err) {\n        param(err);\n      }\n    };\n\n    param(err);\n    \n    // single param callbacks\n    function paramCallback(err) {\n      var fn = paramCallbacks[paramIndex++];\n      if (err || !fn) return param(err);\n      fn(req, res, paramCallback, paramVal, key.name);\n    }\n\n    // invoke route callbacks\n    function callbacks(err) {\n      var fn = route.callbacks[i++];\n      try {\n        if ('route' == err) {\n          nextRoute();\n        } else if (err && fn) {\n          if (fn.length < 4) return callbacks(err);\n          fn(err, req, res, callbacks);\n        } else if (fn) {\n          fn(req, res, callbacks);\n        } else {\n          nextRoute(err);\n        }\n      } catch (err) {\n        callbacks(err);\n      }\n    }\n  })(0);\n};\n\n/**\n * Respond to __OPTIONS__ method.\n *\n * @param {IncomingMessage} req\n * @param {ServerResponse} res\n * @api private\n */\n\nRouter.prototype._options = function(req, res){\n  var path = parse(req.url).pathname\n    , body = this._optionsFor(path).join(',');\n  res.send(body, { Allow: body });\n};\n\n/**\n * Return an array of HTTP verbs or \"options\" for `path`.\n *\n * @param {String} path\n * @return {Array}\n * @api private\n */\n\nRouter.prototype._optionsFor = function(path){\n  var self = this;\n  return methods.filter(function(method){\n    var routes = self.routes[method];\n    if (!routes || 'options' == method) return;\n    for (var i = 0, len = routes.length; i < len; ++i) {\n      if (routes[i].match(path)) return true;\n    }\n  }).map(function(method){\n    return method.toUpperCase();\n  });\n};\n\n/**\n * Attempt to match a route for `req`\n * starting from offset `i`.\n *\n * @param {IncomingMessage} req\n * @param {Number} i\n * @return {Route}\n * @api private\n */\n\nRouter.prototype._match = function(req, i){\n  var method = req.method.toLowerCase()\n    , url = parse(req.url)\n    , path = url.pathname\n    , routes = this.routes\n    , captures\n    , route\n    , keys;\n\n  // pass HEAD to GET routes\n  if ('head' == method) method = 'get';\n\n  // routes for this method\n  if (routes = routes[method]) {\n\n    // matching routes\n    for (var len = routes.length; i < len; ++i) {\n      route = routes[i];\n      if (captures = route.match(path)) {\n        keys = route.keys;\n        route.params = [];\n\n        // params from capture groups\n        for (var j = 1, jlen = captures.length; j < jlen; ++j) {\n          var key = keys[j-1]\n            , val = 'string' == typeof captures[j]\n              ? decodeURIComponent(captures[j])\n              : captures[j];\n          if (key) {\n            route.params[key.name] = val;\n          } else {\n            route.params.push(val);\n          }\n        }\n\n        // all done\n        req._route_index = i;\n        return route;\n      }\n    }\n  }\n};\n\n/**\n * Route `method`, `path`, and one or more callbacks.\n *\n * @param {String} method\n * @param {String} path\n * @param {Function} callback...\n * @return {Router} for chaining\n * @api private\n */\n\nRouter.prototype._route = function(method, path, callbacks){\n  var app = this.app\n    , callbacks = utils.flatten(toArray(arguments, 2));\n\n  // ensure path was given\n  if (!path) throw new Error('app.' + method + '() requires a path');\n\n  // create the route\n  var route = new Route(method, path, callbacks, {\n      sensitive: app.enabled('case sensitive routes')\n    , strict: app.enabled('strict routing')\n  });\n\n  // add it\n  (this.routes[method] = this.routes[method] || [])\n    .push(route);\n  return this;\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":8235}]],"length":8235}
